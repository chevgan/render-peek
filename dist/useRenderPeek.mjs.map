{"version":3,"sources":["../src/useRenderPeek.tsx","../src/utils/injectStyles.ts"],"sourcesContent":["import { useRef, useState, useEffect } from 'react';\nimport equal from 'fast-deep-equal';\nimport { injectStyles } from './utils/injectStyles';\n\nexport interface RenderPeekOptions<P> {\n    ignoreKeys?: (keyof P)[];\n}\n\nexport function useRenderPeek<P extends object>(\n    props: P,\n    options?: RenderPeekOptions<P>\n): { className: string } {\n    // Inject styles once on mount (or first call)\n    injectStyles();\n\n    const prevPropsRef = useRef<P | null>(null);\n    const [shouldFlash, setShouldFlash] = useState(false);\n\n    // Use a ref to track if the flash timeout is active to avoid overlapping timeouts\n    const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n\n    // Helper to filter props based on ignoreKeys\n    const getFilteredProps = (p: P) => {\n        if (!options?.ignoreKeys || options.ignoreKeys.length === 0) {\n            return p;\n        }\n        const filtered: any = { ...p };\n        options.ignoreKeys.forEach((key) => {\n            delete filtered[key];\n        });\n        return filtered;\n    };\n\n    const currentFilteredProps = getFilteredProps(props);\n\n    if (prevPropsRef.current) {\n        const prevFilteredProps = getFilteredProps(prevPropsRef.current);\n\n        // Check if props are deeply equal (meaning re-render was likely unnecessary)\n        const isDeepEqual = equal(prevFilteredProps, currentFilteredProps);\n\n        if (isDeepEqual) {\n            // If we are here, it means the component re-rendered but the relevant props didn't change.\n            // We should flash.\n            // We set state during render to trigger a re-render with the class? \n            // Wait, setting state during render is dangerous. \n            // But the requirement says: \"Acknowledge shouldFlash=true, if cleaned currentProps and prevProps are deeply equal, but component renders.\"\n            // And \"Return object { className: string } containing class render-peek-flash if shouldFlash is active.\"\n\n            // If we detect it NOW, we want to return the class NOW.\n            // But we also need to clear it after 500ms.\n\n            // If we use useEffect to set state, the flash will happen on the NEXT render (double render).\n            // If we want it to happen on THIS render, we can't use state for the *trigger*, but we need state for the *cleanup*.\n\n            // Actually, if we are inside the render function, and we detect equality, we know this CURRENT render is unnecessary.\n            // So we can return the class immediately.\n            // BUT, we need to trigger a re-render to REMOVE the class after 500ms.\n\n            // Let's try this logic:\n            // 1. Detect equality.\n            // 2. If equal, set a flag `isUnnecessary` = true.\n            // 3. If `isUnnecessary`, we return the class.\n            // 4. We also need to schedule a cleanup. We can use useEffect for that.\n\n            // However, if we simply return the class based on comparison, that works for the *current* render.\n            // But we need to make sure `shouldFlash` turns off.\n\n            // Let's refine the state usage.\n            // The prompt says: \"Use useState to control shouldFlash and setTimeout to automatically reset flash after 500ms.\"\n\n            // If I set state in useEffect, I get a flash on the *next* frame (or immediate re-render).\n            // \"Acknowledge shouldFlash=true... but component renders\".\n\n            // If I do:\n            // if (equal) setShouldFlash(true) -> this causes infinite loop if not careful.\n\n            // Correct approach for \"flash on this render\":\n            // We can't easily \"flash on this render\" with state if the state wasn't already true.\n            // But we can derive `isUnnecessary` from props comparison.\n\n            // Let's look at the requirement again: \"Use useState to control shouldFlash\".\n            // This implies the flash state is managed by React state.\n\n            // Implementation:\n            // useEffect(() => {\n            //   if (prevProps) { compare... if equal -> setShouldFlash(true) }\n            //   prevProps = currentProps\n            // })\n            // This would cause the flash to appear AFTER the render has committed, causing a second render with the flash.\n            // This is acceptable and standard for such tools (you see the update, then the flash appears).\n            // Trying to flash *during* the unnecessary render is hard because the render is already happening.\n            // Actually, if the render is unnecessary, the DOM might not update, but we want to force an update to show the flash.\n            // So a second render is required to show the flash anyway (since the first render had no visual changes by definition of \"unnecessary\").\n\n            // So:\n            // 1. Render happens.\n            // 2. Effect runs.\n            // 3. Effect compares props.\n            // 4. If equal, setShouldFlash(true).\n            // 5. Re-render with flash class.\n            // 6. Timeout clears flash.\n\n            // Wait, the prompt says: \"If prevProps exists, before comparison props must be cleaned... Activate shouldFlash=true if cleaned currentProps and prevProps are deep equal\".\n\n            // I will implement it inside useEffect to avoid side-effects during render.\n        }\n    }\n\n    useEffect(() => {\n        const currentFiltered = getFilteredProps(props);\n\n        if (prevPropsRef.current) {\n            const prevFiltered = getFilteredProps(prevPropsRef.current);\n\n            if (equal(prevFiltered, currentFiltered)) {\n                setShouldFlash(true);\n\n                if (timeoutRef.current) {\n                    clearTimeout(timeoutRef.current);\n                }\n\n                timeoutRef.current = setTimeout(() => {\n                    setShouldFlash(false);\n                    timeoutRef.current = null;\n                }, 500);\n            }\n        }\n\n        prevPropsRef.current = props;\n    }, [props, options]); // Dependencies: props change triggers this.\n\n    return {\n        className: shouldFlash ? 'render-peek-flash' : '',\n    };\n}\n","const css = `\n@keyframes peek-flash-anim {\n  0% {\n    box-shadow: inset 0 0 0 2px #ff4500;\n  }\n  100% {\n    box-shadow: inset 0 0 0 2px transparent;\n  }\n}\n\n.render-peek-flash {\n  animation: peek-flash-anim 0.5s ease-out forwards;\n}\n`;\n\nlet injected = false;\n\nexport function injectStyles() {\n    if (typeof document === 'undefined' || injected) return;\n\n    const style = document.createElement('style');\n    style.type = 'text/css';\n    style.innerHTML = css;\n    document.head.appendChild(style);\n    injected = true;\n}\n"],"mappings":"AAAA,OAAS,UAAAA,EAAQ,YAAAC,EAAU,aAAAC,MAAiB,QAC5C,OAAOC,MAAW,kBCDlB,IAAMC,EAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAeRC,EAAW,GAER,SAASC,GAAe,CAC3B,GAAI,OAAO,SAAa,KAAeD,EAAU,OAEjD,IAAME,EAAQ,SAAS,cAAc,OAAO,EAC5CA,EAAM,KAAO,WACbA,EAAM,UAAYH,EAClB,SAAS,KAAK,YAAYG,CAAK,EAC/BF,EAAW,EACf,CDjBO,SAASG,EACZC,EACAC,EACqB,CAErBC,EAAa,EAEb,IAAMC,EAAeC,EAAiB,IAAI,EACpC,CAACC,EAAaC,CAAc,EAAIC,EAAS,EAAK,EAG9CC,EAAaJ,EAA6C,IAAI,EAG9DK,EAAoBC,GAAS,CAC/B,GAAI,CAACT,GAAS,YAAcA,EAAQ,WAAW,SAAW,EACtD,OAAOS,EAEX,IAAMC,EAAgB,CAAE,GAAGD,CAAE,EAC7B,OAAAT,EAAQ,WAAW,QAASW,GAAQ,CAChC,OAAOD,EAASC,CAAG,CACvB,CAAC,EACMD,CACX,EAEME,EAAuBJ,EAAiBT,CAAK,EAEnD,GAAIG,EAAa,QAAS,CACtB,IAAMW,EAAoBL,EAAiBN,EAAa,OAAO,EAGzDY,EAAcC,EAAMF,EAAmBD,CAAoB,CAoErE,CAEA,OAAAI,EAAU,IAAM,CACZ,IAAMC,EAAkBT,EAAiBT,CAAK,EAE9C,GAAIG,EAAa,QAAS,CACtB,IAAMgB,EAAeV,EAAiBN,EAAa,OAAO,EAEtDa,EAAMG,EAAcD,CAAe,IACnCZ,EAAe,EAAI,EAEfE,EAAW,SACX,aAAaA,EAAW,OAAO,EAGnCA,EAAW,QAAU,WAAW,IAAM,CAClCF,EAAe,EAAK,EACpBE,EAAW,QAAU,IACzB,EAAG,GAAG,EAEd,CAEAL,EAAa,QAAUH,CAC3B,EAAG,CAACA,EAAOC,CAAO,CAAC,EAEZ,CACH,UAAWI,EAAc,oBAAsB,EACnD,CACJ","names":["useRef","useState","useEffect","equal","css","injected","injectStyles","style","useRenderPeek","props","options","injectStyles","prevPropsRef","useRef","shouldFlash","setShouldFlash","useState","timeoutRef","getFilteredProps","p","filtered","key","currentFilteredProps","prevFilteredProps","isDeepEqual","equal","useEffect","currentFiltered","prevFiltered"]}